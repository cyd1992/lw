# 1 绪论

## 1.1课题背景
-------------

本课题在基于国家数据广播中心原有的系统的基础上，进一步实现了支持多人收看电视直播与回看节目的一整套解决方案。该系统可以将卫星采集下来的高清电视节目通过流媒体服务器，变为可供观看的视频流。同时将直播节目录制成视频文件以供回看。最后，跨平台的视频播放器保证用户可以随时随地观看到视频节目。


## 1.2 选题的意义与研究价值
------------------------

的说法是的范德萨发斯蒂芬

## 1.3 作者的主要工作
------------------

作者完成了整套系统的设计与实现。包括整体软件的架构设计、回看服务器软件设计与开发，数据库设计，节目管理系统的设计与开发以及各个平台播放器客户端的设计与开发。

## 1.4 论文的组织结构
-------------------




#2 整体方案设计



## 2.1 系统方案设计
----------------
系统由前端、边缘服务器及用户构成。blablabla 
整体系统框图如图所示

![pic1](src/3.png =x400) 


###### 前端功能
1. 卫星直转系统接收来自卫星的电视节目及自办节目，重新编码为低码率H.264直播流，分发到直播服务器。
2. 直播服务器为流媒体服务器，
3. 提供DNS域名解析服务，采集边缘服务器状态，指导用户连接到合适的边缘服务器
4. 提供NTP服务，为整个网络提供基于GPS的时间基准
5. 提供热备份。

##### 边缘服务器功能
1. 边缘服务器具备双网口，跨网段使用；
2. 主干网口连接主干网，接收直播流、同步点播节目及接收EPG；
3. 子网段口连接子网段，提供不高于3000路并发的直播、回看、点播服务；
4. 主干网口也可提供不高于300路并发的直播、回看、点播服务。

##### 用户功能及种类
1. 用户位于子网段内，通过网页或APP访问TV.com，观看直播、回看、点播节目；
2. 用户终端支持电脑、平板及苹果手机的网页访问，安卓盒子及手机的APP访问；
3. 子网段内可挂接多个WIFI无线路由器，提供无线访问能力。


------------------------

网络拓扑图如图所示

![pic3](src/2.png =x350)

主（备）前端连主干网，提供直播流、点播节目、DNS（域名解析）、EPG（电子节目单）及NTP（网络时间协议）服务。外部4G信号接入前端，提供EPG及远程维护功能。
边缘服务器具备双网口，一端连主干网，接收直播流；另一端连子网段，提供直播、回看、点播服务。当子网段用户过多时，可安装多套边缘服务器。
     
用户分布于各个子网段内，通过前端DNS解析，得到最近的边缘服务器IP，进而申请直播、回看、点播服务。当访问主前端失败时，可自动访问备份前端。

前端由卫星直转系统，电视转码系统，高清编码系统和播出服务器系统构成。

------------------------



## 2.2 前端系统
前端系统完成IPTV及数字电视播出。为可靠起见，前端系统采用双备份，在主前端故障时，IPTV会自动切换到备份前端，数字电视系统需要手动切换。如图所示

![pic2](src/4.png =x400) 



前端完成IPTV及数字电视播出，输入为卫星电视与4G信号，输出为有线电视RF信号及IPTV万兆光接口。
前端网络分为内外两张网，内网完成核心的电视转码系统及高清编码系统；外网提供主直播/点播服务和主干网其它服务。内网通过路由器与外网连接，以保证内网的安全可靠性。
内网通过管理服务器接入4G信号，实现外部远程系统管理和EPG获取。
前端分为主前端与备份前端，两者结构相同，相应IP地址不同，方便用户及边缘服务器自动切换。







##### 卫星直转系统
卫星直转系统介绍见“岛礁有线电视方案”，主要完成100套卫星节目接收，解调，拼接，调制，最终输出为有线电视RF信号。
IPTV系统节目源大部分来自卫星直转系统，通过系统改造，将节目通过增加的ASI接口输出至“数字电视转IP”单元。
     
##### 电视转码系统
电视转码系统由数字电视IP转换及转码机两部分构成，数字电视IP转换接收ASI输入的多套MCPC电视节目，转为SCPC的单节目UDP流，发送到指定的转码机；转码机完成多路UDP节目接收、视音频解码，H.264视频/AAC音频编码，通过RTMP协议发送到直播服务器。
单台数字电视转IP完成6路ASI接收，本系统有12路ASI流，需要2台数字电视IP转换设备；单台转码机完成16套标清或8套高清节目转码，需5台转码机完成80套节目实时转码。

##### 高清编码系统
高清编码系统由32台高清机顶盒和或HDMI高清编播系统（自办高清直播节目），2主2从高清编码机，蓝网、广播接收机构成。完成32套高清统计复用编码，同时插入蓝网、广播节目，输出的ASI送到直转系统调制器，输出的IPTV通过RTMP协议发送到直播服务器。

##### 播出服务器
播出服务器由直播服务器、点播服务器、DNS/EPG/NTP服务器构成。
直播服务器完成100套IPTV节目RTMP接收及向多个边缘直播服务器分发功能；
点播服务器完成点播节目及蓝色海疆数据广播节目接收、存储及与边缘点播服务器同步；  
DNS服务器完成DNS域名解析及边缘服务器信息收集与配置，返回用户合适边缘服务器的IP地址；
EPG服务器通过4G得到外部实时EPG，为边缘的回看服务器自动录制提供电子节目单。EPG是一个实时动态数据库，需要购买及长期人工维护；
NTP服务器通过GPS/北斗校时，为系统提供精确可靠的时间信息；
另外，播出系统还配备管理服务器，通过4G远程配置与监视系统工作。
   

##### 前端网络布局
 前端网络分为内外两张网，内网完成核心的电视转码系统及高清编码系统；外网提供主直播/点播服务和主干网其它服务。内网通过路由器与外网连接，以保证内网的安全性。
内网通过管理服务器接入4G信号，实现外部远程系统管理和EPG获取。
前端分为主前端与备份前端，两者结构相同，功能相同，仅IP地址不同，互为热备份。
 



------------------------------

本课题在已有的卫星只转系统与电视转码系统的基础上，进一步实现岛礁直播点播系统以供岛礁上的用户可以方便的观看直播与点播的电视节目。
系统用例图如图所示

![pic5](src/4.jpg =x400)











# 3  直播与回看服务器的设计与实现
-----------------------------
## 3.1 直播与回看管理软件的设计与实现
--------------------------------

### 3.1.1 系统需求分析
-----------------
对系统进行基本的需求分析之后，可知该管理软件至少应该具有如下功能：<br>
1. 系统管理员可以添家直播频道的信息。
2. 系统管理员可以删除直播频道的信息。
3. 系统管理员可以编辑直播频道的信息。
4. 系统管理员可以启动回看节目的录制。
5. 系统管理员可以停止回看节目的录制。
6. 系统管理员可以监控回看节目的录制情况。

通过对系统需求的分析，可以确定该系统的参与者即为系统管理员。可以确定系统中有如下用例存在。<br>

1. Add Channel Info（添加直播频道信息）<br>
本用例提供了添加直播频道信息的功能
2. Delete Channel Info（删除直播频道信息）<br>
本用例提供了删除直播频道信息的功能。
3. Edit Channel Info （编辑直播频道信息）<br>
本用例提供了编辑直播频道信息的功能。
4. Start Replay (启动回看节目录制)<br>
本用例提供了启动回看节目录制的功能。
5. Stop Replay(停止回看节目录制)<br>
本用例提供了停止回看节目录制的功能。

系统用例图如图所示：

![system](src/system.png =x300)


### 3.1.2 定义系统对象
-----------------------
定义完系统需求，就可以根据系统需求来识别系统中存在的对象了。系统对象的识别可以通过寻找系统域描述和需求描述中的名词来进行。从这些对象翅中筛选，如果有与该对象相关的身份和行为，那么久应该为之创建类。
1. 类Channel<br>
类Channel代表直播频道的信息。直播频道的信息包括频道的唯一id、名称、直播流的地址。 类Channel应该具有下列私有属性。<br>
channel_id:String <br>
直播频道的唯一id<br>
channel_name:String <br>
直播频道的名称<br>
url:String <br>
直播流的地址<br>
active:boolean<br>
激活状态<br>
start:boolean<br>
回看节目的录制状态<br>

在确定Channel的公共操作包括如下：

query()
查询是否存在对应的直播频道信息。

update() <br>
更新直播频道信息的内容，如改变频道名称，直播流地址以及激活状态和录制状态。



2. 类Program <br>
类Program代表回看节目的信息。类Program应该具有下列私有属性<br>


在确定Channel的方法时，应考虑如下需求：
add()
增加一条回看节目信息

delete()
删除指定的回看节目


### 3.1.3 数据库的设计与实现
-------------------------
本系统共有两个实体类，即类Channel与类Program。类Channel与类Program为一对多的关联关系。

根据已有需求，建立数据库模型。数据库的逻辑模型如下图所示。本系统使用关系型数据库存储和管理数据。关系表的UML符号用衍型为<<retional table>>的类符号表示，带有衍型<<pk>>的属性代表主键，带有<<fk>>的属性代表外键。

![database](src/database.png =x200)

本系统数据库共有两个表，channel中表包含了所有频道的数据。其中“channel_id”为描述频道的唯一id，“channel_name”为频道名字，“rtmp_url”为直播流的url地址，“active”为激活标志，“start”为是否启动录制回看节目的标志。program存储所有回看节目的数据，其中“channel_id”为描述频道的唯一id，“start_time”与“end_time”为回看节目的起始时间与结束时间，“url”为录制节目的url地址，“finished”为录制成功的标志位，”title”为回看节目的名称。<br>
channel表与program表为一对多的关系。channel表与program表之间的一对多关系通过在表program中插入外检“channel_id”以匹配channel表中的“channel_id”来模拟。

创建好数据库之后，需要对数据库的进行初始化：<br>



### 3.1.4 定义用户界面类
----------------------
系统管理员与系统需要交互，一个用户友好的系统通常都采用直观的图形化界面，因此需要定义系统的用户界面类。

1. 类TSTable
TSTable是系统的主界面，为一个显示直播频道信息的列表。每一行显示的是直播频道信息，其中包括直播频道的id、名称、直播流的地址，回看录制机ip等信息。每条信息都提供编辑删除按钮。点击按钮上便可以编辑或删除该条信息。同时，每条直播频道信息都有一个录制按钮，当按下录制按钮时，启动回看录制程序。再次按下停止。界面如图所示：<br>

![TSTable](src/TSTable.png =x350)

公共方法如下：<br>
newTSTable() : void<br>
创建系统主界面。<br>
edit() : void<br>
当按下“编辑”按钮时，该方法被调用，编辑对应的直播频道信息。<br>
delete() : void<br>
当按下“删除”按钮时，该方法被调用，删除对应的直播频道信息。<br>
addChannel() : void<br>
当按下“添加”按钮时，该方法被调用，添加一条新的直播频道信息。<br>
start() : void <br>
当按下“录制”按钮时，该方法被调用
stop() : void <br>
当处于录制状态按下“录制”按钮时，该方法被调用。


2. 类AddDialog
界面类AddDialog是用来添加一条新的直播频道信息。当按下TSTable中的“添加”按钮时，对话框AddDialog弹出，管理员填写相关的直播频道信息，点击“提交”按钮，便可将该条信息添加到系统数据库中并显示出来。界面如图所示：<br>

![Dialog](src/Dialog.png =x400)

类AddDialog具有如下方法：<br>
newDialog() : void<br>
创建添加窗口<br>
add() : void<br>
当添加窗口被提交时，该方法被调用。

3. 类EditDialog
界面类EditDialog的功能与AddDialog较为相似，用来重新编辑一条直播频道信息。当按下TSTable中的“编辑”按钮时
，弹出EditDialog对话框。管理员修改相关的信息，点击“提交”按钮，便可以修改该条直播频道信息。<br>
类EditDialog具有如下方法
newDialog() : void <br>
创建编辑窗口 <br>
edit() : void <br>
当编辑窗口被提交时，该方法被调用。

### 3.1.5 直播与回看管理软件的具体实现
---------------------------------
描述本系统用例场景的时序图如下：<br>

添加直播频道信息的时序图如图所示： <br>

![add](src/add.png =x400)


当要添加直播频道信息时。管理员发送add()消息给类TSTable，类TSTable又发送newDialog()消息给类AddDialog,即类AddDialog的方法被调用，创建用于添加直播频道信息的对话框。管理员填写必要的信息之后提交信息，类AddDialog的方法add()被调用，发送消息给Channel类，首先调用Channel类中的query方法，确认数据库中是否存在该条信息，如若存在（若不存在，则显示提示信息）,则调用add方法，更新并激活该条信息。


编辑与删除直播频道信息的流程与添加直播频道信息的流程类似。不同的是TSTable所调用的方法分别为edit与delete方法。<br>
启动与停止录制回看视频的时序图如图所示：<br>

![start](src/start.png =x400)

当要启动或停止录制回看视频时，管理员发送send()消息给类TSTable，类TSTable通过当前显示状态判断是进行启动还是停止操作，接着，类TSTable发送start或者stop命令给管理服务器，最后管理服务器发送start或者stop命令给远程的回看录制服务器。最后回看录制服务器返回程序执行的结果，并显示在用户界面上。



## 3.2 EPG同步服务器的设计与实现
-------------------------------


### 3.2.1 EPG简介
----------------
EPG 是Electronic Program Guide的英文缩写，意思是电子节目指南。 IPTV所提供的各种业务的索引及导航都是通过 EPG系统来完成的。 IPTV EPG实际上就是 IPTV的一个门户系统。 EPG系统的界面与 Web页面类似，在 EPG界面上一般都提供各类菜单、按钮、链接等可供用户选择节目时直接点击的组件； EPG的界面上也可以包含各类供用户浏览的动态或静态的多媒体内容。
EPG的主要作用就是用户利用EPG提供的菜单，可以选择自己喜欢的组播频道；点播自己喜欢的视频节目；在线演唱自己喜欢的歌曲；查找IPTV提供的各种信息，包括生活信息、娱乐信息、教育信息、体育信息等等；用户也可使用EPG提供的菜单来订购自己喜欢的节目；甚至可以通过EPG提供的菜单支付水费、电费、进行电子商务的交易等。用户还可以利用EPG菜单查看节目的附加信息，例如对节目内容介绍、演员及导演的介绍等。同时通过EPG菜单中提供的家长控制功能，家长可以对某些节目加以限制，不给孩子开放所有的观看权限。
EPG为IPTV提供的基本业务(如VOD点播/KTV/歌曲)及各种增值业务的使用提供了简单方便的操作平台，为IPTV用户收看电视节目、享受多媒体节目点播以及开展信息服务提供了一个良好的导航机制。使用EPG系统可使用户能够方便快捷地找到自己关心的节目。使用EPG系统，用户通过电视机这个终端和IP机顶盒就可以登陆Internet。更重要的是使用EPG系统用户就可以和电视进行互动，这样用户就不再被动地接收信息，用户可以及时、主动地发表自己的意见和看法，并将这些意见和看法及时反馈给内容制作商。因此EPG在IPTV系统中起着十分重要的作用。



### 3.2.2 EPG同步服务器系统设计
----------------------------
EPG同步服务器主要实时同步100套电视直播节目的EPG信息，并对外提供相应的数据接口。EPG同步服务器的系统框图如图所示：

首先，服务器每隔一段时间，便从第三方数据源处获取实时的EPG更新数据。















## 3.3 直播服务器的设计与实现
--------------------------
### 3.3.1 开源流媒体服务器srs
--------------------------
SRS定位是运营级的互联网直播服务器集群，追求更好的概念完整性和最简单实现的代码。SRS提供了丰富的接入方案将RTMP流接入SRS，包括推送RTMP到SRS、拉取流到SRS。SRS还支持将接入的RTMP流进行各种变换，譬如直播流转码、转发给其他服务器、转封装成HLS、录制成FLV。SRS包含支大规模集群如CDN业务的关键特性，譬如RTMP多级集群、VHOST虚拟服务器、无中断服务Reload。此外，SRS还提供丰富的应用接口，包括HTTP回调、HTTP API接口、RTMP测速。SRS在源站和CDN集群中都得到了广泛的应用Applications。<br />

* 运营级：<br/>
商业运营追求极高的稳定性，良好的系统对接，以及错误排查和处理机制。譬如日志文件格式，reload，系统HTTP接口，提供init.d脚本，转发，转码，边缘回多源站，都是根据CDN运营经验作为判断这些功能作为核心的依据。
* 互联网：<br/>
互联网最大的特征是变化，唯一不变的就是不断变化的客户要求，唯一不变的是基础结构的概念完整性和简洁性。互联网还意味着参与性，听取用户的需求和变更，持续改进和维护。
* 直播服务器：<br>
直播和点播这两种截然不同的业务类型，导致架构和目标完全不一致，从运营的设备组，应对的挑战都完全不同。两种都支持只能说明没有重心，或者低估了代价。
* 集群：<br>
FMS(AMS)的集群还是很不错的，虽然在运营容错很差。SRS（Simple Rtmp Server）支持完善的直播集群，Vhost分为源站和边缘，容错支持多源站切换、测速、可追溯日志等。
* 概念完整性：
虽然代码甚至结构都在变化，但是结构的概念完整性是一直追求的目标。从SRS（Simple Rtmp Server）服务器，P2P，ARM监控产业，MIPS路由器，服务器监控管理，ARM智能手机，SRS（Simple Rtmp Server）的规模不再是一个服务器而已。
* 简单实现：
对于过于复杂的实现，宁可不加入这个功能，也不牺牲前面提到的要求。对于已经实现的功能的代码，总会在一个版本release前给予充分的时间来找出最简答案。不求最高性能，最优雅，最牛逼，但求最简单易懂。

与nginx-rtmp相比，SRS(Simple Rtmp Server)单进程能支持9000并发，nginx-rtmp单进程最多支持3000个，单进程的性能SRS(Simple Rtmp Server)是nginx-rtmp的三倍。srs针对直播服务器有如下优化：

第一点，st-load，这个是SRS(Simple Rtmp Sever)能做到高性能的最重要的原因，一个st-load可以模拟2000+的客户端。一个牛逼的benchmark的工具；如果没有st-load，如何知道系统的性能瓶颈在哪里？总不能打开3000个flash页面播放rtmp流吧？开启3000个ffmpeg来抓流？不靠谱。这就是高性能第一定律：高性能不是想象和猜测粗来的，而是测试、调试和改进粗来的。
第二点，gperf/gprof性能benchmark功能。在编译SRS(Simple Rtmp Sever)时，就可以打开gcp或者gprof的性能分析选项，灰常方便就可以拿到数据。缩短了改进和优化的开发周期。
第三点，引用计数的msgs避免内存拷贝。从编码器收到的video/audio数据，转换成SrsSharedPtrMessage放到每个连接的发送队列，避免每个都拷贝一次；因为发送给每个客户端的消息(不是chunked包)头可能不一样，譬如时间戳不一样，但是消息的payload是一样的。
第四点，使用writev发送chunked包，避免消息到chunked包的内存拷贝。可以开辟一个header的缓冲区，专门放每个chunked包的header，然后用iovc保存头的指针和大小，payload的指针和大小，用writev就可以一次发送。
第五点，mw(merged-write)技术，即一次发送多个消息。虽然每个消息使用writev可以避免拷贝，还有更高效的是一次发送多个消息，即把多个消息的chunked头写在header的缓冲区，iovc保存多个消息的chunked头和payload指针，一次writev发送多个消息。这个是最关键所在。
第六点，减少timeout recv，每个连接都是一个st-thread在服务。在发送之前，线程得尝试从连接收取消息，譬如客户端的stop之类的；所以只能recv时指定timeout，譬如300毫秒如果还没有收到消息，就发送连接队列中的消息。这个会导致st的timeout红黑树操作频繁。实际上，可以直接开启一个recv线程，因为客户端的消息非常少，避免timeout接收。
第七点，fast buffer和cache。譬如每次取消息的数组，使用cache；使用fast buffer避免频繁删除；使用header的cache。
第八点，vector还是list？有的地方看起来list更高效，譬如simple buffer这种频繁删除头，以及在结尾加入数据，看起来是list应该做的事情。但是实际上测试发现，vector比list高10%性能。所以，回到第一点，高性能不是猜测和想象粗来的；有的时候有些代码写得很慢，但是这个频率非常低，那么就不要考虑性能，而要考虑可读性。我觉得可以算是高性能第二定律：不要总是考虑高性能，可读性更重要。

### 3.2.2 流媒体协议分析

1 rtmp<br>

RTMP(Real Time Messaging Protoc01)协议 是传输层协议,是基于TCP的协议。创建的是长 连接。它像一个用来装数据包的容器,这些数据可以是AMF格式的数据,也可以是FI。V中的视/音 频数据。在RTMP中控制信息和媒体数据都称之 为message。由于PTMP是基于TCP的,并且 message的长度会很长,所以RTMP采用了一种 分片的策略。每一个分片称为chunk。每个message被分解成一个或多个chunk。


2 HLS<br>

HTTP Live Streaming（缩写是HLS）是一个由苹果公司提出的基于HTTP的流媒体网络传输协议。是苹果公司QuickTime和iPhone软件系统的一部分。它的工作原理是把整个流分成一个个小的基于HTTP的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的extended M3U (m3u8)playlist文件，用于寻找可用的媒体流。
HLS只请求基本的HTTP报文，与实时传输协议（RTP)不同，HLS可以穿过任何允许HTTP数据通过的防火墙或者代理服务器。它也很容易使用内容分发网络来传输媒体流。
苹果公司把HLS协议作为一个互联网草案（逐步提交），在第一阶段中已作为一个非正式的标准提交到IETF。但是，即使苹果偶尔地提交一些小的更新，IETF却没有关于制定此标准的有关进一步的动作。

HLS协议规定：

视频的封装格式是TS。
视频的编码格式为H264,音频编码格式为MP3、AAC或者AC-3。
除了TS视频文件本身，还定义了用来控制播放的m3u8文件（文本文件）。
HLS主要是为了解决RTMP协议存在的一些问题。比如RTMP协议不使用标准的HTTP接口传输数据，所以在一些特殊的网络环境下可能被防火墙屏蔽掉。但是HLS由于使用的HTTP协议传输数据，不会遇到被防火墙屏蔽的情况（该不会有防火墙连80接口都不放过吧）。
另外于负载，RTMP是一种有状态协议，很难对视频服务器进行平滑扩展，因为需要为每一个播放视频流的客户端维护状态。而HLS基于无状态协议（HTTP），客户端只是按照顺序使用下载存储在服务器的普通TS文件，做负责均衡如同普通的HTTP文件服务器的负载均衡一样简单。
另外HLS协议本身实现了码率自适应，不同带宽的设备可以自动切换到最适合自己码率的视频播放。其实HLS最大的优势就是他的亲爹是苹果。苹果在自家的IOS设备上只提供对HLS的原生支持，并且放弃了flash。Android也迫于平果的“淫威”原生支持了HLS。这样一来flv，rtmp这些Adobe的视频方案要想在移动设备上播放需要额外下点功夫。当然flash对移动设备造成很大的性能压力确实也是自身的问题。




### 3.2.2 srs的部署与使用
-----------------------

SRS主要运行在Linux系统上，譬如Centos和Ubuntu，包括x86、x86-64、ARM和MIPS。MacOS支持代码编辑和编译。
SRS的系统结构如图所示：

在下载源码、确定用什么编译选项后，编译SRS其实很简单。只需要RTMP和HLS：

  ./configure && make

指定配置文件，即可启动SRS：

  ./objs/srs -c conf/srs.conf
  
SRS启动之后，只需要将直播流以RTMP的形式推送到服务器上，便可以










## 3.3 回看服务器的设计与实现
--------------------------

### 3.3.1 系统分析
-----------------
在图xxx中，我们看到，系统管理员在回看管理软件中，点击“启动”按钮时，管理服务器会发送一条命令给回看服务器，此时，回看服务器便把指定的直播源根据EPG信息录制成回看视频文件并存放在回看服务器中。由此我们知道，回看服务器的主要功能便是从直播流中录制可供用户观看的电视节目。流程图如图所示，首先，回看服务器先从EPG同步服务器中将对应的EPG信息存储在本地数据库中，接着，回看服务器从指定的流中录制视频，并根据实时的EPG信息生成回看视频文件，最后讲生成的回看视频信息写入数据库中一遍用户进行观看。

从图中我们可以看到，实现回看服务器的关键便是从指定流中录制视频这一过程，既要考虑程序运行的稳定性、又要考虑生成视频格式的兼容性等等问题。在开发过程中，一共实现过过以下三个方案:

1. 将rtmp直播流录制成flv文件存储在本地http服务器。流程图如图所示：

![rtmp](src/rtmp.png =x600)


初次启动录制时在命令行中输入脚本名后加入channel_id作为运行参数，以达到录制相应频道节目的目的。创建文件目录和程序运行日志，目录存在则跳过，日志如果存在则从最后一行开始记录。根据channel_id从channel表中获取RTMP码流地址并测试码流是否获取正常。如果测试失败则将数据库中运行状态和主进程号写0并终止程序，如果测试通过则将主进程号和运行状态1写入数据库并将进行下一步操作，从节目单接口获取跟channel_id相对应的XML格式节目数据，然后将其中有用的部分进行解析和处理后保存在数据库中。然后根据channel_id和当前系统时间，从刚刚保存在数据库的program表中找到符合当前时间的节目并准备开始录制。如果当前时间刚好处在两段节目中间的空档期时，则进入等待状态直到节目播出时间后再准备开始录制。
到达节目录制时间后，程序为当前节目文件创建临时文件名dump.flv和随机文件名变量，这是因为直接抓取的直播流数据文件没有节目的时长信息，在页面播放器中播放节目时会造成无法拖动的问题，所以每个节目录制时先以临时文件名dump.flv保存，待录制结束后注入元数据并生成最终的节目文件，然后删除临时文件。
然后再次以当前channel_id及日期创建文件夹和子文件夹，目的是解决节目循环录制过程中遇到日起变化的问题，如果文件夹已存在则跳过该步骤，创建当前节目文件的保存路径变量，创建码流录制命令变量，创建元信息注入命令变量，创建节目录制子进程变量，创建进程组号变量，完成上述操作后，开始录制节目文件。
录制节目进行中，每隔60秒进行节目剩余时间判断及码流判断，如果判断出现码流不正常，则跳出该录制子进程并重新开始录制，直到码流恢复正常为止。如果码流正常则继续录制，节目结束前60秒停止判断。结束后进行元信息注入并保存节目文件，删除临时录制文件，删除72小时前的节目单信息和节目文件，将录制好的节目地址及完成状态写入数据库中，结束录制子进程。完成上述步骤后后重新回到读取节目单信息的步骤，从节目单接口更新节目单数据，然后读取一条合适的节目信息并开始录制循环。如果节目单出现更新问题，无法获取新的节目单，则每隔30秒重试1次，共5次。5次获取节目单信息失败后程序等待30分钟再次重试5次，直到节目单接口能够正常获取数据为止。为了优化程序结构，便于管理维护，将录制部分的程序分为：录制脚本rtmpdump.py、数据库管理脚本db_manager.py及关闭脚本kill.py。软件整体框架


2. 将hls直播流中的ts文件重组，以m3u8索引文件的格式存储在本地http服务器中。由于hls直播流由一个个长度为10秒的ts文件组成。对ts文件进行简单拼接，存储在本地。再生成对应的m3u8文件，即可完成对直播视频的录制任务，流程图如图所示。<br>

![hls](src/hls.png =x600)

初次启动录制时以程序输入的channel_id作为参数，以达到录制相应频道节目的目的。创建文件目录和程序运行日志，目录存在则跳过，日志如果存在则从最后一行开始记录。根据channel_id从channel表中获取RTMP码流地址，将RTMP码流地址映射为对应的hls码流地址并测试码流是否获取正常，如果测试失败则修改数据库中该频道的录制状态并终止程序。如果测试通过则进行下一步操作。程序创建一个新的进程，将原来长度为10秒的ts文件拼接，生成全新的长度为60秒的ts文件并存储在本地。与此同时，程序主进程每隔三十分钟对服务器中所有进行录制的频道进行如下操作：（1）从EPG同步服务器中更新最新的EPG信息到服务器中。（2）根据数据库中的EPG信息与本地存储的ts文件，生成对应的m3u8文件以供用户观看。（2）删除本地文件系统中陈旧的视频节目。


3. 将udp流文件录制成ts切片，以m3u8索引文件的形式存储在本地http服务器中。与方案二不同的是，视频录制的源的网络传输协议从hls变成了udp。


在经过大量的测试得知，对于节目时长过长的节目来说，方法1中使用rtmp录制下来的flv文件往往过大，这使得在网络传输中造成了不必要的带宽浪费。而且flv文件无法再苹果公司的ios平台浏览其中进行播放，影响了系统的兼容性。方法2将视频格式由flv编程了ts格式，解决了兼容性问题，但是由于其录制时会产生累计误差，导致录制时间与系统时间偏移较大。因此最终选用方案3中的方式进行录制。



### 3.3.2 回看服务器的程序实现
---------------------------
回来看服务器中的录制程序使用Python3.5进行编写，服务器选用flask框架用于与管理服务器进行通信。程序模块图如图所示：









# 4 客户端播放器的设计与实现

## 4.1 概述
----------

## 4.2 网页播放器
----------------


## 4.3 手机浏览器播放器
--------------------
## 4.4 安卓手机客户端播放器
------------------------

## 4.5 安卓机顶盒播放器
--------------------

# 5 系统测试与分析
--------------------------------



#6
------------------------












